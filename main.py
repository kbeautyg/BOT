import os
import json
import re
import asyncio
from datetime import datetime, timedelta, timezone
from zoneinfo import ZoneInfo
import logging # Import logging module

from aiogram import Bot, Dispatcher, Router, F
from aiogram.filters import Command
from aiogram.types import (
    Message, CallbackQuery, InlineKeyboardButton, InlineKeyboardMarkup
)
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext

from supabase import create_client, Client
from dotenv import load_dotenv

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# CONFIG & INIT
load_dotenv() # –ø–æ–¥—Ç—è–≥–∏–≤–∞–µ–º .env

BOT_TOKEN = os.getenv("BOT_TOKEN")
SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_KEY = os.getenv("SUPABASE_KEY")

if not all((BOT_TOKEN, SUPABASE_URL, SUPABASE_KEY)):
    logging.error("‚ùå BOT_TOKEN / SUPABASE_URL / SUPABASE_KEY ‚Äì –ø—Ä–æ–≤–µ—Ä—å .env")
    raise SystemExit("‚ùå BOT_TOKEN / SUPABASE_URL / SUPABASE_KEY ‚Äì –ø—Ä–æ–≤–µ—Ä—å .env")

bot = Bot(token=BOT_TOKEN, parse_mode=None)
dp = Dispatcher(storage=MemoryStorage())

# SUPABASE THIN WRAPPER
class SupabaseDB:
    """–ü—Ä–æ—Å—Ç–µ–π—à–∏–π —Å–ª–æ–π –≤–æ–∫—Ä—É–≥ Supabase/PostgREST —Å–æ —Å—Ö–µ–º–æ–π, –Ω—É–∂–Ω–æ–π –±–æ—Ç—É."""
    def __init__(self, url: str, key: str): # Added __init__ method
        self.client: Client = create_client(url, key)
        logging.info("Supabase client initialized.")

    # ---------- USERS ----------
    def get_user(self, user_id: int):
        try:
            res = self.client.table("users").select("*").eq("user_id", user_id).execute()
            return (res.data or [None])[0]
        except Exception as e:
            logging.error(f"Error getting user {user_id}: {e}")
            return None

    def ensure_user(self, user_id: int, default_lang="ru"):
        try:
            user = self.get_user(user_id)
            if user:
                return user
            tpl = dict(user_id=user_id, language=default_lang, timezone="UTC", date_format="YYYY-MM-DD", time_format="HH:mm", notify_before=0)
            res = self.client.table("users").insert(tpl).execute()
            logging.info(f"User {user_id} ensured/created.")
            return res.data[0]
        except Exception as e:
            logging.error(f"Error ensuring user {user_id}: {e}")
            return None

    def update_user(self, user_id: int, fields: dict):
        if not fields:
            return
        try:
            self.client.table("users").update(fields).eq("user_id", user_id).execute()
            logging.info(f"User {user_id} updated with fields: {fields}")
        except Exception as e:
            logging.error(f"Error updating user {user_id} with fields {fields}: {e}")

    # ---------- PROJECTS ----------
    def create_project(self, owner_id: int, name: str):
        try:
            proj = self.client.table("projects").insert({"name": name, "owner_id": owner_id}).execute().data[0]
            self.client.table("user_projects").insert({"user_id": owner_id, "project_id": proj["id"], "role": "owner"}).execute()
            logging.info(f"Project '{name}' created by user {owner_id}.")
            return proj
        except Exception as e:
            logging.error(f"Error creating project '{name}' for owner {owner_id}: {e}")
            return None

    def list_projects(self, user_id: int):
        try:
            memberships = self.client.table("user_projects").select("project_id, role").eq("user_id", user_id).execute().data
            pids = [m["project_id"] for m in memberships]
            if not pids:
                return []
            projects_data = self.client.table("projects").select("*").in_("id", pids).execute().data
            
            project_roles = {m["project_id"]: m["role"] for m in memberships}
            for project in projects_data:
                project["role"] = project_roles.get(project["id"])
            return projects_data
        except Exception as e:
            logging.error(f"Error listing projects for user {user_id}: {e}")
            return []

    def is_member(self, user_id: int, project_id: int):
        try:
            return bool(self.client.table("user_projects").select("user_id")
                        .eq("user_id", user_id).eq("project_id", project_id).execute().data)
        except Exception as e:
            logging.error(f"Error checking membership for user {user_id} in project {project_id}: {e}")
            return False

    def get_user_project_role(self, user_id: int, project_id: int):
        try:
            res = self.client.table("user_projects").select("role").eq("user_id", user_id).eq("project_id", project_id).execute()
            return (res.data or [None])[0]["role"] if res.data else None
        except Exception as e:
            logging.error(f"Error getting role for user {user_id} in project {project_id}: {e}")
            return None

    def add_user_to_project(self, user_id: int, project_id: int, role: str):
        try:
            data = {"user_id": user_id, "project_id": project_id, "role": role}
            res = self.client.table("user_projects").upsert(data, on_conflict="user_id,project_id").execute().data[0]
            logging.info(f"User {user_id} added/updated in project {project_id} with role {role}.")
            return res
        except Exception as e:
            logging.error(f"Error adding user {user_id} to project {project_id} with role {role}: {e}")
            return None

    def remove_user_from_project(self, user_id: int, project_id: int):
        try:
            self.client.table("user_projects").delete().eq("user_id", user_id).eq("project_id", project_id).execute()
            logging.info(f"User {user_id} removed from project {project_id}.")
        except Exception as e:
            logging.error(f"Error removing user {user_id} from project {project_id}: {e}")

    def list_project_members(self, project_id: int):
        try:
            return self.client.table("user_projects").select("user_id, role").eq("project_id", project_id).execute().data
        except Exception as e:
            logging.error(f"Error listing members for project {project_id}: {e}")
            return []

    # ---------- CHANNELS ----------
    def add_channel(self, project_id: int, chat_id: int, title: str):
        try:
            data = {"project_id": project_id, "chat_id": chat_id, "name": title}
            res = self.client.table("channels").upsert(data, on_conflict="project_id,chat_id").execute().data[0]
            logging.info(f"Channel '{title}' ({chat_id}) added to project {project_id}.")
            return res
        except Exception as e:
            logging.error(f"Error adding channel '{title}' ({chat_id}) to project {project_id}: {e}")
            return None

    def list_channels(self, project_id: int):
        try:
            return self.client.table("channels").select("*").eq("project_id", project_id).execute().data
        except Exception as e:
            logging.error(f"Error listing channels for project {project_id}: {e}")
            return []

    def del_channel(self, chan_internal_id: int):
        try:
            self.client.table("channels").delete().eq("id", chan_internal_id).execute()
            logging.info(f"Channel {chan_internal_id} deleted.")
        except Exception as e:
            logging.error(f"Error deleting channel {chan_internal_id}: {e}")

    # ---------- POSTS ----------
    def new_post(self, fields: dict):
        try:
            if "buttons" in fields and isinstance(fields["buttons"], list):
                fields["buttons"] = json.dumps(fields["buttons"])
            res = self.client.table("posts").insert(fields).execute().data[0]
            logging.info(f"New post created: {res.get('id')}")
            return res
        except Exception as e:
            logging.error(f"Error creating new post with fields {fields}: {e}")
            return None

    def get_post(self, post_id: int):
        try:
            return (self.client.table("posts").select("*").eq("id", post_id).execute().data or [None])[0]
        except Exception as e:
            logging.error(f"Error getting post {post_id}: {e}")
            return None

    def update_post(self, post_id: int, fields: dict):
        try:
            if "buttons" in fields and isinstance(fields["buttons"], list):
                fields["buttons"] = json.dumps(fields["buttons"])
            self.client.table("posts").update(fields).eq("id", post_id).execute()
            logging.info(f"Post {post_id} updated with fields: {fields}")
        except Exception as e:
            logging.error(f"Error updating post {post_id} with fields {fields}: {e}")

    def delete_post(self, post_id: int):
        try:
            self.client.table("posts").delete().eq("id", post_id).execute()
            logging.info(f"Post {post_id} deleted.")
        except Exception as e:
            logging.error(f"Error deleting post {post_id}: {e}")

    def pending_posts(self, now_iso: str):
        try:
            return self.client.table("posts") \
                .select("*") \
                .eq("published", False) \
                .eq("draft", False) \
                .lte("publish_time", now_iso) \
                .execute().data
        except Exception as e:
            logging.error(f"Error getting pending posts for {now_iso}: {e}")
            return []

    def mark_published(self, post_id: int):
        try:
            self.update_post(post_id, {"published": True})
            logging.info(f"Post {post_id} marked as published.")
        except Exception as e:
            logging.error(f"Error marking post {post_id} as published: {e}")

db = SupabaseDB(SUPABASE_URL, SUPABASE_KEY) # Instantiated db object correctly

# GLOBAL CONSTANTS / TEXTS
TEXTS = {
    "ru": {
        "start": "ü§ñ –ë–æ—Ç –≥–æ—Ç–æ–≤. /help ‚Äî —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥.",
        "help": ("/create ‚Äî –Ω–æ–≤—ã–π –ø–æ—Å—Ç\n"
                 "/list ‚Äî –ø–æ—Å—Ç—ã\n"
                 "/channels ‚Äî –∫–∞–Ω–∞–ª—ã\n"
                 "/project ‚Äî –ø—Ä–æ–µ–∫—Ç—ã\n"
                 "/settings ‚Äî –Ω–∞—Å—Ç—Ä–æ–π–∫–∏\n"
                 "/cancel ‚Äî –æ—Ç–º–µ–Ω–∞\n"
                 "/current_project ‚Äî —Ç–µ–∫—É—â–∏–π –ø—Ä–æ–µ–∫—Ç\n"
                 "/project_select ‚Äî –≤—ã–±—Ä–∞—Ç—å –ø—Ä–æ–µ–∫—Ç\n"
                 "/project_add ‚Äî —Å–æ–∑–¥–∞—Ç—å –ø—Ä–æ–µ–∫—Ç\n"
                 "/manage_users ‚Äî —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏ –ø—Ä–æ–µ–∫—Ç–∞\n"),
        "no_channels": "–°–Ω–∞—á–∞–ª–∞ –¥–æ–±–∞–≤—å –∫–∞–Ω–∞–ª —á–µ—Ä–µ–∑ /channels add",
        "enter_post_text": "–í–≤–µ–¥–∏ —Ç–µ–∫—Å—Ç –ø–æ—Å—Ç–∞:",
        "attach_media": "–ü—Ä–∏–∫—Ä–µ–ø–∏—Ç—å —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ? (–ø—Ä–∏—à–ª–∏ —Ñ–∞–π–ª –∏–ª–∏ /skip)",
        "enter_buttons": "–ö–Ω–æ–ø–∫–∏ (–∫–∞–∂–¥–∞—è –Ω–∞ –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–µ: –¢–µ–∫—Å—Ç | url). –ï—Å–ª–∏ –Ω–µ –Ω—É–∂–Ω–æ ‚Äî /skip",
        "publish_time": "–ö–æ–≥–¥–∞ –ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å? (–ø—Ä–∏–º–µ—Ä: 2025-12-01 18:45)\n–ò–ª–∏ /skip –¥–ª—è –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ",
        "invalid_date_format": "‚ùå –§–æ—Ä–º–∞—Ç –¥–∞—Ç—ã –Ω–µ–≤–µ—Ä–Ω—ã–π. –ü—Ä–∏–º–µ—Ä: 2025-12-01 18:45",
        "repeat_post": "–ü–æ–≤—Ç–æ—Ä—è—Ç—å –ø–æ—Å—Ç? (0 ‚Äî –Ω–µ –ø–æ–≤—Ç–æ—Ä—è—Ç—å, –∏–Ω–∞—á–µ —á–∏—Å–ª–æ –º–∏–Ω—É—Ç)",
        "invalid_repeat_format": "‚ùå –í–≤–µ–¥–∏ —á–∏—Å–ª–æ –º–∏–Ω—É—Ç (0 ‚Äî –Ω–µ –ø–æ–≤—Ç–æ—Ä—è—Ç—å)",
        "no_projects": "–ù–µ—Ç –ø—Ä–æ–µ–∫—Ç–æ–≤. –°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π –ø—Ä–æ–µ–∫—Ç —á–µ—Ä–µ–∑ /project_add",
        "pick_channel": "–í –∫–∞–∫–æ–π –∫–∞–Ω–∞–ª –ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å?",
        "post_saved": "‚úÖ –ü–æ—Å—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω –∏ –±—É–¥–µ—Ç –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω –ø–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é.",
        "post_cancelled": "‚ùå –û—Ç–º–µ–Ω–µ–Ω–æ",
        "no_channels_to_delete": "–ù–µ—Ç –∫–∞–Ω–∞–ª–æ–≤ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.",
        "select_channel_to_delete": "–í—ã–±–µ—Ä–∏ –∫–∞–Ω–∞–ª –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:",
        "channel_deleted": "–ö–∞–Ω–∞–ª —É–¥–∞–ª—ë–Ω.",
        "enter_channel_info": "–í–≤–µ–¥–∏ @username –∏–ª–∏ ID –∫–∞–Ω–∞–ª–∞:",
        "channel_not_found": "‚ùå –ö–∞–Ω–∞–ª –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å, —á—Ç–æ –±–æ—Ç –∞–¥–º–∏–Ω.",
        "only_channels_supported": "‚ùå –¢–æ–ª—å–∫–æ –∫–∞–Ω–∞–ª—ã/–≥—Ä—É–ø–ø—ã –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è",
        "channel_added": "‚úÖ –ö–∞–Ω–∞–ª –¥–æ–±–∞–≤–ª–µ–Ω.",
        "your_channels": "–¢–≤–æ–∏ –∫–∞–Ω–∞–ª—ã:\n",
        "your_projects": "–¢–≤–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã:\n",
        "enter_project_name": "–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞:",
        "project_created": "‚úÖ –ü—Ä–æ–µ–∫—Ç —Å–æ–∑–¥–∞–Ω: ",
        "settings_menu": "–ù–∞—Å—Ç—Ä–æ–π–∫–∏:\n–Ø–∑—ã–∫: {language}\n–¢–∞–π–º–∑–æ–Ω–∞: {timezone}\n–§–æ—Ä–º–∞—Ç –¥–∞—Ç—ã: {date_format}\n–§–æ—Ä–º–∞—Ç –≤—Ä–µ–º–µ–Ω–∏: {time_format}",
        "select_language": "–í—ã–±–µ—Ä–∏ —è–∑—ã–∫:",
        "language_updated": "–Ø–∑—ã–∫ –æ–±–Ω–æ–≤–ª–µ–Ω.",
        "post_not_found": "–ü–æ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.",
        "no_posts_yet": "–ü–æ—Å—Ç–æ–≤ –ø–æ–∫–∞ –Ω–µ—Ç.",
        "post_deleted": "–ü–æ—Å—Ç —É–¥–∞–ª—ë–Ω.",
        "enter_new_post_text": "–í–≤–µ–¥–∏ –Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç –ø–æ—Å—Ç–∞:",
        "text_updated": "–¢–µ–∫—Å—Ç –æ–±–Ω–æ–≤–ª—ë–Ω.",
        "no_projects_found": "–ù–µ—Ç –ø—Ä–æ–µ–∫—Ç–æ–≤.",
        "no_channels_found": "–ù–µ—Ç –∫–∞–Ω–∞–ª–æ–≤.",
        "add_channel_first": "–°–Ω–∞—á–∞–ª–∞ –¥–æ–±–∞–≤—å –∫–∞–Ω–∞–ª —á–µ—Ä–µ–∑ /channels add",
        "select_project": "–í—ã–±–µ—Ä–∏ –ø—Ä–æ–µ–∫—Ç:",
        "project_selected": "‚úÖ –ü—Ä–æ–µ–∫—Ç '{project_name}' –≤—ã–±—Ä–∞–Ω.",
        "project_not_found": "–ü—Ä–æ–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.",
        "current_project": "–¢–µ–∫—É—â–∏–π –ø—Ä–æ–µ–∫—Ç: {project_name}",
        "no_active_project": "–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞. –í—ã–±–µ—Ä–∏ –ø—Ä–æ–µ–∫—Ç —á–µ—Ä–µ–∑ /project_select",
        "access_denied": "–£ —Ç–µ–±—è –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –ø—Ä–æ–µ–∫—Ç—É –∏–ª–∏ –∫–æ–º–∞–Ω–¥–µ.",
        "user_not_found": "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.",
        "enter_user_id_or_username": "–í–≤–µ–¥–∏ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–ª–∏ @username –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è/–∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–æ–ª–∏:",
        "select_role": "–í—ã–±–µ—Ä–∏ —Ä–æ–ª—å –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_info}:",
        "role_updated": "–†–æ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_info} –æ–±–Ω–æ–≤–ª–µ–Ω–∞ –Ω–∞ '{role}'.",
        "user_added_to_project": "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_info} –¥–æ–±–∞–≤–ª–µ–Ω –≤ –ø—Ä–æ–µ–∫—Ç '{project_name}' —Å —Ä–æ–ª—å—é '{role}'.",
        "user_already_member": "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_info} —É–∂–µ —è–≤–ª—è–µ—Ç—Å—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–º –ø—Ä–æ–µ–∫—Ç–∞ '{project_name}'.",
        "user_removed_from_project": "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_info} —É–¥–∞–ª–µ–Ω –∏–∑ –ø—Ä–æ–µ–∫—Ç–∞ '{project_name}'.",
        "confirm_remove_user": "–¢—ã —É–≤–µ—Ä–µ–Ω, —á—Ç–æ —Ö–æ—á–µ—à—å —É–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_info} –∏–∑ –ø—Ä–æ–µ–∫—Ç–∞ '{project_name}'?",
        "yes": "–î–∞",
        "no": "–ù–µ—Ç",
        "user_management_menu": "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏ –ø—Ä–æ–µ–∫—Ç–∞ '{project_name}':",
        "add_user": "–î–æ–±–∞–≤–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
        "remove_user": "–£–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
        "list_users": "–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π",
        "manage_users": "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏",
        "project_users": "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –ø—Ä–æ–µ–∫—Ç–∞ '{project_name}':",
        "no_users_in_project": "–í —ç—Ç–æ–º –ø—Ä–æ–µ–∫—Ç–µ –Ω–µ—Ç –¥—Ä—É–≥–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.",
        "select_user_to_remove": "–í—ã–±–µ—Ä–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:",
        "user_removed": "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–¥–∞–ª–µ–Ω.",
        "set_timezone": "–í–≤–µ–¥–∏ —Å–≤–æ—é —Ç–∞–π–º–∑–æ–Ω—É (–Ω–∞–ø—Ä–∏–º–µ—Ä, Europe/Moscow –∏–ª–∏ America/New_York):",
        "invalid_timezone": "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ç–∞–π–º–∑–æ–Ω—ã. –ü–æ–ø—Ä–æ–±—É–π –µ—â–µ —Ä–∞–∑ (–Ω–∞–ø—Ä–∏–º–µ—Ä, Europe/Moscow).",
        "timezone_updated": "–¢–∞–π–º–∑–æ–Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞.",
        "set_datetime_format": "–í–≤–µ–¥–∏ —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, YYYY-MM-DD) –∏ –≤—Ä–µ–º–µ–Ω–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, HH:mm) —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª:",
        "invalid_datetime_format": "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò—Å–ø–æ–ª—å–∑—É–π YYYY, MM, DD, HH, mm. –ü—Ä–∏–º–µ—Ä: YYYY-MM-DD HH:mm",
        "datetime_format_updated": "–§–æ—Ä–º–∞—Ç –¥–∞—Ç—ã/–≤—Ä–µ–º–µ–Ω–∏ –æ–±–Ω–æ–≤–ª–µ–Ω.",
        "error": "–û—à–∏–±–∫–∞",
        "not_owner": "–¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –ø—Ä–æ–µ–∫—Ç–∞ –º–æ–∂–µ—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏.",
    },
    "en": {
        "start": "ü§ñ Bot is ready. /help for commands.",
        "help": ("/create ‚Äî new post\n"
                 "/list ‚Äî posts\n"
                 "/channels ‚Äî channels\n"
                 "/project ‚Äî projects\n"
                 "/settings ‚Äî settings\n"
                 "/cancel ‚Äî cancel\n"
                 "/current_project ‚Äî current project\n"
                 "/project_select ‚Äî select project\n"
                 "/project_add ‚Äî create project\n"
                 "/manage_users ‚Äî manage project users\n"),
        "no_channels": "Add a channel first via /channels add",
        "enter_post_text": "Enter post text:",
        "attach_media": "Attach photo/video? (send file or /skip)",
        "enter_buttons": "Buttons (each on a new line: Text | url). If not needed ‚Äî /skip",
        "publish_time": "When to publish? (example: 2025-12-01 18:45)\nOr /skip for immediate",
        "invalid_date_format": "‚ùå Invalid date format. Example: 2025-12-01 18:45",
        "repeat_post": "Repeat post? (0 ‚Äî no repeat, otherwise number of minutes)",
        "invalid_repeat_format": "‚ùå Enter number of minutes (0 ‚Äî no repeat)",
        "no_projects": "No projects. Create a project first via /project_add",
        "pick_channel": "Which channel to publish to?",
        "post_saved": "‚úÖ Post saved and will be published on schedule.",
        "post_cancelled": "‚ùå Cancelled",
        "no_channels_to_delete": "No channels to delete.",
        "select_channel_to_delete": "Select channel to delete:",
        "channel_deleted": "Channel deleted.",
        "enter_channel_info": "Enter @username or channel ID:",
        "channel_not_found": "‚ùå Channel not found. Make sure the bot is an admin.",
        "only_channels_supported": "‚ùå Only channels/groups are supported",
        "channel_added": "‚úÖ Channel added.",
        "your_channels": "Your channels:\n",
        "your_projects": "Your projects:\n",
        "enter_project_name": "Enter new project name:",
        "project_created": "‚úÖ Project created: ",
        "settings_menu": "Settings:\nLanguage: {language}\nTimezone: {timezone}\nDate format: {date_format}\nTime format: {time_format}",
        "select_language": "Select language:",
        "language_updated": "Language updated.",
        "post_not_found": "Post not found.",
        "no_posts_yet": "No posts yet.",
        "post_deleted": "Post deleted.",
        "enter_new_post_text": "Enter new post text:",
        "text_updated": "Text updated.",
        "no_projects_found": "No projects.",
        "no_channels_found": "No channels.",
        "add_channel_first": "Add a channel first via /channels add",
        "select_project": "Select project:",
        "project_selected": "‚úÖ Project '{project_name}' selected.",
        "project_not_found": "Project not found.",
        "current_project": "Current project: {project_name}",
        "no_active_project": "No active project. Select a project via /project_select",
        "access_denied": "You do not have access to this project or command.",
        "user_not_found": "User not found.",
        "enter_user_id_or_username": "Enter user ID or @username to add/change role:",
        "select_role": "Select role for user {user_info}:",
        "role_updated": "User {user_info}'s role updated to '{role}'.",
        "user_added_to_project": "User {user_info} added to project '{project_name}' with role '{role}'.",
        "user_already_member": "User {user_info} is already a member of project '{project_name}'.",
        "user_removed_from_project": "User {user_info} removed from project '{project_name}'.",
        "confirm_remove_user": "Are you sure you want to remove user {user_info} from project '{project_name}'?",
        "yes": "Yes",
        "no": "No",
        "user_management_menu": "Project '{project_name}' user management:",
        "add_user": "Add user",
        "remove_user": "Remove user",
        "list_users": "List users",
        "manage_users": "Manage users",
        "project_users": "Users in project '{project_name}':",
        "no_users_in_project": "No other users in this project.",
        "select_user_to_remove": "Select user to remove:",
        "user_removed": "User removed.",
        "set_timezone": "Enter your timezone (e.g., Europe/Moscow or America/New_York):",
        "invalid_timezone": "‚ùå Invalid timezone format. Please try again (e.g., Europe/Moscow).",
        "timezone_updated": "Timezone updated.",
        "set_datetime_format": "Enter date format (e.g., YYYY-MM-DD) and time format (e.g., HH:mm) separated by space:",
        "invalid_datetime_format": "‚ùå Invalid format. Use YYYY, MM, DD, HH, mm. Example: YYYY-MM-DD HH:mm",
        "datetime_format_updated": "Date/time format updated.",
        "error": "Error",
        "not_owner": "Only project owner can manage users.",
    }
}

# HELPERS
TOKEN_MAP = {"YYYY": "%Y", "YY": "%y", "MM": "%m", "DD": "%d", "HH": "%H", "mm": "%M"}
_rx = re.compile("|".join(sorted(TOKEN_MAP, key=len, reverse=True)))

def fmt2strptime(dfmt: str, tfmt: str) -> str:
    return _rx.sub(lambda m: TOKEN_MAP[m.group(0)], f"{dfmt} {tfmt}")

def parse_dt(user_cfg: dict, text: str) -> datetime:
    dfmt, tfmt = user_cfg["date_format"], user_cfg["time_format"]
    fmt = fmt2strptime(dfmt, tfmt)
    dt = datetime.strptime(text, fmt)
    tz = ZoneInfo(user_cfg.get("timezone", "UTC"))
    return dt.replace(tzinfo=tz).astimezone(ZoneInfo("UTC"))

# FSM STATES
class CreatePost(StatesGroup):
    text = State()
    media = State()
    buttons = State()
    datetime = State()
    repeat = State()
    channel = State()
    confirm = State()

class ProjectStates(StatesGroup):
    new_project_name = State()
    select_project = State()
    manage_users = State()
    add_user_id = State()
    add_user_role = State()
    remove_user_confirm = State()
    remove_user_select = State()

class ChannelStates(StatesGroup):
    add_channel_name = State()

class SettingsStates(StatesGroup):
    set_timezone = State()
    set_datetime_format = State()

# ROUTERS (start / help / cancel)
base_router = Router()
channels_router = Router()
projects_router = Router()
posts_router = Router()

@base_router.message(Command("start"))
async def cmd_start(m: Message):
    u = db.ensure_user(m.from_user.id, default_lang=(m.from_user.language_code or "ru")[:2])
    await m.answer(TEXTS[u["language"]]["start"])

@base_router.message(Command("help"))
async def cmd_help(m: Message):
    lang = (db.get_user(m.from_user.id) or {}).get("language", "ru")
    await m.answer(TEXTS[lang]["help"])

@base_router.message(Command("cancel"))
async def cmd_cancel(m: Message, state: FSMContext):
    await state.clear()
    lang = (db.get_user(m.from_user.id) or {}).get("language", "ru")
    await m.answer(TEXTS[lang]["post_cancelled"])

# –ö–ê–ù–ê–õ–´ (–¥–æ–±–∞–≤–∏—Ç—å/—É–¥–∞–ª–∏—Ç—å/—Å–ø–∏—Å–æ–∫)
@channels_router.message(Command("channels"))
async def channels_menu(m: Message):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    
    active_project_id = u.get("active_project_id")
    if not active_project_id:
        await m.answer(TEXTS[lang]["no_active_project"])
        return

    chans = db.list_channels(active_project_id)
    if not chans:
        await m.answer(TEXTS[lang]["no_channels"])
        return
    txt = TEXTS[lang]["your_channels"] + "\n".join(f"{c['name']} ‚Äî {c['chat_id']}" for c in chans)
    await m.answer(txt)

@channels_router.message(Command("add_channel"))
async def add_channel(m: Message, state: FSMContext):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    
    active_project_id = u.get("active_project_id")
    if not active_project_id:
        await m.answer(TEXTS[lang]["no_active_project"])
        return
    
    await state.update_data({"add_channel_project_id": active_project_id})
    await m.answer(TEXTS[lang]["enter_channel_info"])
    await state.set_state(ChannelStates.add_channel_name)

@channels_router.message(F.text, ChannelStates.add_channel_name)
async def add_channel_save(m: Message, state: FSMContext):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    data = await state.get_data()
    project_id = data.get("add_channel_project_id")
    input_txt = m.text.strip()
    try:
        chat = await bot.get_chat(input_txt)
    except Exception:
        await m.answer(TEXTS[lang]["channel_not_found"])
        await state.clear()
        return
    
    if chat.type not in ["channel", "supergroup", "group"]:
        await m.answer(TEXTS[lang]["only_channels_supported"])
        await state.clear()
        return
    
    db.add_channel(project_id, chat.id, chat.title or chat.username or str(chat.id))
    await m.answer(TEXTS[lang]["channel_added"])
    await state.clear()

@channels_router.message(Command("remove_channel"))
async def remove_channel(m: Message, state: FSMContext):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    
    active_project_id = u.get("active_project_id")
    if not active_project_id:
        await m.answer(TEXTS[lang]["no_active_project"])
        return
    
    chans = db.list_channels(active_project_id)
    if not chans:
        await m.answer(TEXTS[lang]["no_channels_to_delete"])
        return
    
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(c["name"], callback_data=f"delch_{c['id']}")] for c in chans
    ])
    await m.answer(TEXTS[lang]["select_channel_to_delete"], reply_markup=kb)

@channels_router.callback_query(F.data.startswith("delch_"))
async def remove_channel_cb(q: CallbackQuery):
    u = db.ensure_user(q.from_user.id)
    lang = u["language"]
    ch_id = int(q.data[6:])
    db.del_channel(ch_id)
    await q.message.edit_text(TEXTS[lang]["channel_deleted"])
    await q.answer()

# –ü–†–û–ï–ö–¢–´ (—Å–æ–∑–¥–∞—Ç—å/—Å–ø–∏—Å–æ–∫/–≤—ã–±–æ—Ä)
@projects_router.message(Command("project"))
async def projects_menu(m: Message):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    projs = db.list_projects(m.from_user.id)
    if not projs:
        await m.answer(TEXTS[lang]["no_projects"])
        return
    
    txt = TEXTS[lang]["your_projects"] + "\n".join(f"{p['id']}: {p['name']} (Role: {p['role']})" for p in projs)
    await m.answer(txt)

@projects_router.message(Command("project_add"))
async def project_add(m: Message, state: FSMContext):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    await m.answer(TEXTS[lang]["enter_project_name"])
    await state.set_state(ProjectStates.new_project_name)

@projects_router.message(F.text, ProjectStates.new_project_name)
async def project_add_save(m: Message, state: FSMContext):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    name = m.text.strip()
    p = db.create_project(m.from_user.id, name)
    await m.answer(TEXTS[lang]["project_created"] + name)
    await state.clear()

@projects_router.message(Command("project_select"))
async def project_select(m: Message, state: FSMContext):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    projs = db.list_projects(m.from_user.id)
    if not projs:
        await m.answer(TEXTS[lang]["no_projects"])
        return
    
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(f"{p['name']} ({p['role']})", callback_data=f"selproj_{p['id']}")] for p in projs
    ])
    await m.answer(TEXTS[lang]["select_project"], reply_markup=kb)

@projects_router.callback_query(F.data.startswith("selproj_"))
async def project_selected_cb(q: CallbackQuery):
    u = db.ensure_user(q.from_user.id)
    lang = u["language"]
    project_id = int(q.data[8:])
    
    # Check if user is a member of this project
    if not db.is_member(q.from_user.id, project_id):
        await q.answer(TEXTS[lang]["access_denied"], show_alert=True)
        return

    db.update_user(q.from_user.id, {"active_project_id": project_id})
    
    # Get project name for confirmation message
    project = (db.client.table("projects").select("name").eq("id", project_id).execute().data or [None])[0]
    project_name = project["name"] if project else "Unknown"

    await q.message.edit_text(TEXTS[lang]["project_selected"].format(project_name=project_name))
    await q.answer()

@projects_router.message(Command("current_project"))
async def current_project(m: Message):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    
    active_project_id = u.get("active_project_id")
    if not active_project_id:
        await m.answer(TEXTS[lang]["no_active_project"])
        return
    
    project = (db.client.table("projects").select("name").eq("id", active_project_id).execute().data or [None])[0]
    if project:
        await m.answer(TEXTS[lang]["current_project"].format(project_name=project["name"]))
    else:
        await m.answer(TEXTS[lang]["project_not_found"])

@projects_router.message(Command("manage_users"))
async def manage_users_menu(m: Message):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]

    active_project_id = u.get("active_project_id")
    if not active_project_id:
        await m.answer(TEXTS[lang]["no_active_project"])
        return
    
    user_role = db.get_user_project_role(m.from_user.id, active_project_id)
    if user_role != "owner":
        await m.answer(TEXTS[lang]["not_owner"])
        return
    
    project = (db.client.table("projects").select("name").eq("id", active_project_id).execute().data or [None])[0]
    project_name = project["name"] if project else "Unknown"

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(TEXTS[lang]["add_user"], callback_data="manage_add_user")],
        [InlineKeyboardButton(TEXTS[lang]["remove_user"], callback_data="manage_remove_user")],
        [InlineKeyboardButton(TEXTS[lang]["list_users"], callback_data="manage_list_users")],
    ])
    await m.answer(TEXTS[lang]["user_management_menu"].format(project_name=project_name), reply_markup=kb)

@projects_router.callback_query(F.data == "manage_add_user")
async def manage_add_user_start(q: CallbackQuery, state: FSMContext):
    u = db.ensure_user(q.from_user.id)
    lang = u["language"]
    await q.message.edit_text(TEXTS[lang]["enter_user_id_or_username"])
    await state.set_state(ProjectStates.add_user_id)
    await q.answer()

@projects_router.message(F.text, ProjectStates.add_user_id)
async def manage_add_user_id(m: Message, state: FSMContext):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    
    user_input = m.text.strip()
    target_user_id = None
    user_info_display = user_input

    try:
        target_user_id = int(user_input)
        target_user_tg = await bot.get_chat(target_user_id)
        user_info_display = target_user_tg.full_name or target_user_tg.username or str(target_user_id)
    except ValueError: # Not an integer, try as username
        if user_input.startswith('@'):
            try:
                target_user_tg = await bot.get_chat(user_input)
                target_user_id = target_user_tg.id
                user_info_display = target_user_tg.full_name or target_user_tg.username or str(target_user_id)
            except Exception:
                await m.answer(TEXTS[lang]["user_not_found"])
                await state.clear()
                return
        else:
            await m.answer(TEXTS[lang]["user_not_found"])
            await state.clear()
            return
    except Exception: # Telegram API error for get_chat
        await m.answer(TEXTS[lang]["user_not_found"])
        await state.clear()
        return

    if target_user_id == m.from_user.id:
        await m.answer("–¢—ã –Ω–µ –º–æ–∂–µ—à—å –∏–∑–º–µ–Ω–∏—Ç—å —Å–≤–æ—é —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—É—é —Ä–æ–ª—å —á–µ—Ä–µ–∑ —ç—Ç—É –∫–æ–º–∞–Ω–¥—É.")
        await state.clear()
        return

    active_project_id = u.get("active_project_id")
    if not active_project_id: # Should be checked by manage_users_menu
        await m.answer(TEXTS[lang]["no_active_project"])
        await state.clear()
        return

    await state.update_data({"target_user_id": target_user_id, "user_info_display": user_info_display})

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton("Member", callback_data="role_member")],
        [InlineKeyboardButton("Admin", callback_data="role_admin")],
        [InlineKeyboardButton("Owner", callback_data="role_owner")],
    ])
    await m.answer(TEXTS[lang]["select_role"].format(user_info=user_info_display), reply_markup=kb)
    await state.set_state(ProjectStates.add_user_role)

@projects_router.callback_query(F.data.startswith("role_"), ProjectStates.add_user_role)
async def manage_add_user_role(q: CallbackQuery, state: FSMContext):
    u = db.ensure_user(q.from_user.id)
    lang = u["language"]
    data = await state.get_data()
    target_user_id = data["target_user_id"]
    user_info_display = data["user_info_display"]
    role = q.data[5:]

    active_project_id = u.get("active_project_id")
    project = (db.client.table("projects").select("name").eq("id", active_project_id).execute().data or [None])[0]
    project_name = project["name"] if project else "Unknown"

    db.add_user_to_project(target_user_id, active_project_id, role)
    await q.message.edit_text(TEXTS[lang]["user_added_to_project"].format(user_info=user_info_display, project_name=project_name, role=role))
    await state.clear()
    await q.answer()

@projects_router.callback_query(F.data == "manage_list_users")
async def manage_list_users(q: CallbackQuery):
    u = db.ensure_user(q.from_user.id)
    lang = u["language"]

    active_project_id = u.get("active_project_id")
    if not active_project_id:
        await q.answer(TEXTS[lang]["no_active_project"], show_alert=True)
        return
    
    user_role = db.get_user_project_role(q.from_user.id, active_project_id)
    if user_role != "owner":
        await q.answer(TEXTS[lang]["not_owner"], show_alert=True)
        return

    members = db.list_project_members(active_project_id)
    project = (db.client.table("projects").select("name").eq("id", active_project_id).execute().data or [None])[0]
    project_name = project["name"] if project else "Unknown"

    if not members:
        await q.message.edit_text(TEXTS[lang]["no_users_in_project"])
        await q.answer()
        return

    txt = TEXTS[lang]["project_users"].format(project_name=project_name) + "\n"
    for member in members:
        try:
            member_tg = await bot.get_chat(member["user_id"])
            member_info = member_tg.full_name or member_tg.username or str(member["user_id"])
        except Exception:
            member_info = f"ID: {member['user_id']}"
        txt += f"- {member_info} ({member['role']})\n"
    
    await q.message.edit_text(txt)
    await q.answer()

@projects_router.callback_query(F.data == "manage_remove_user")
async def manage_remove_user_start(q: CallbackQuery, state: FSMContext):
    u = db.ensure_user(q.from_user.id)
    lang = u["language"]

    active_project_id = u.get("active_project_id")
    if not active_project_id:
        await q.answer(TEXTS[lang]["no_active_project"], show_alert=True)
        return
    
    user_role = db.get_user_project_role(q.from_user.id, active_project_id)
    if user_role != "owner":
        await q.answer(TEXTS[lang]["not_owner"], show_alert=True)
        return

    members = db.list_project_members(active_project_id)
    if not members or (len(members) == 1 and members[0]["user_id"] == q.from_user.id):
        await q.message.edit_text(TEXTS[lang]["no_users_in_project"])
        await q.answer()
        return

    kb_buttons = []
    for member in members:
        if member["user_id"] != q.from_user.id: # Cannot remove self
            try:
                member_tg = await bot.get_chat(member["user_id"])
                member_info = member_tg.full_name or member_tg.username or str(member["user_id"])
            except Exception:
                member_info = f"ID: {member['user_id']}"
            kb_buttons.append([InlineKeyboardButton(f"{member_info} ({member['role']})", callback_data=f"rmuser_{member['user_id']}")])
    
    if not kb_buttons:
        await q.message.edit_text(TEXTS[lang]["no_users_in_project"])
        await q.answer()
        return

    kb = InlineKeyboardMarkup(inline_keyboard=kb_buttons)
    await q.message.edit_text(TEXTS[lang]["select_user_to_remove"], reply_markup=kb)
    await state.set_state(ProjectStates.remove_user_select)
    await q.answer()

@projects_router.callback_query(F.data.startswith("rmuser_"), ProjectStates.remove_user_select)
async def manage_remove_user_confirm(q: CallbackQuery, state: FSMContext):
    u = db.ensure_user(q.from_user.id)
    lang = u["language"]
    
    target_user_id = int(q.data[7:])
    
    active_project_id = u.get("active_project_id")
    project = (db.client.table("projects").select("name").eq("id", active_project_id).execute().data or [None])[0]
    project_name = project["name"] if project else "Unknown"

    try:
        target_user_tg = await bot.get_chat(target_user_id)
        user_info_display = target_user_tg.full_name or target_user_tg.username or str(target_user_id)
    except Exception:
        user_info_display = f"ID: {target_user_id}"

    await state.update_data({"target_user_id_to_remove": target_user_id, "user_info_display_to_remove": user_info_display})

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(TEXTS[lang]["yes"], callback_data="confirm_remove_yes")],
        [InlineKeyboardButton(TEXTS[lang]["no"], callback_data="confirm_remove_no")],
    ])
    await q.message.edit_text(TEXTS[lang]["confirm_remove_user"].format(user_info=user_info_display, project_name=project_name), reply_markup=kb)
    await state.set_state(ProjectStates.remove_user_confirm)
    await q.answer()

@projects_router.callback_query(F.data.startswith("confirm_remove_"), ProjectStates.remove_user_confirm)
async def manage_remove_user_execute(q: CallbackQuery, state: FSMContext):
    u = db.ensure_user(q.from_user.id)
    lang = u["language"]
    data = await state.get_data()
    target_user_id = data["target_user_id_to_remove"]
    user_info_display = data["user_info_display_to_remove"]

    active_project_id = u.get("active_project_id")

    if q.data == "confirm_remove_yes":
        db.remove_user_from_project(target_user_id, active_project_id)
        await q.message.edit_text(TEXTS[lang]["user_removed_from_project"].format(user_info=user_info_display, project_name="")) # Project name already in previous message
    else:
        await q.message.edit_text(TEXTS[lang]["post_cancelled"]) # Reusing cancel text
    
    await state.clear()
    await q.answer()

# –ù–ê–°–¢–†–û–ô–ö–ò (—Ç–∞–π–º–∑–æ–Ω–∞, —è–∑—ã–∫, —Ñ–æ—Ä–º–∞—Ç)
@projects_router.message(Command("settings"))
async def settings_menu(m: Message, state: FSMContext):
    u = db.get_user(m.from_user.id)
    txt = TEXTS[u["language"]]["settings_menu"].format(
        language=u['language'],
        timezone=u['timezone'],
        date_format=u['date_format'],
        time_format=u['time_format']
    )
    kb = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(TEXTS[u["language"]]["select_language"], callback_data="set_lang")],
            [InlineKeyboardButton(TEXTS[u["language"]]["set_timezone"], callback_data="set_tz")],
            [InlineKeyboardButton(TEXTS[u["language"]]["set_datetime_format"], callback_data="set_fmt")],
        ]
    )
    await m.answer(txt, reply_markup=kb)

@projects_router.callback_query(F.data == "set_lang")
async def set_lang(q: CallbackQuery, state: FSMContext):
    u = db.ensure_user(q.from_user.id)
    lang = u["language"]
    kb = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton("–†—É—Å—Å–∫–∏–π", callback_data="lang_ru")],
            [InlineKeyboardButton("English", callback_data="lang_en")],
        ]
    )
    await q.message.edit_text(TEXTS[lang]["select_language"], reply_markup=kb)
    await q.answer()

@projects_router.callback_query(F.data.in_(["lang_ru", "lang_en"]))
async def lang_selected(q: CallbackQuery):
    u = db.ensure_user(q.from_user.id)
    lang = u["language"]
    selected_lang = "ru" if q.data == "lang_ru" else "en"
    db.update_user(q.from_user.id, {"language": selected_lang})
    await q.message.edit_text(TEXTS[selected_lang]["language_updated"])
    await q.answer()

@projects_router.callback_query(F.data == "set_tz")
async def set_tz_start(q: CallbackQuery, state: FSMContext):
    u = db.ensure_user(q.from_user.id)
    lang = u["language"]
    await q.message.edit_text(TEXTS[lang]["set_timezone"])
    await state.set_state(SettingsStates.set_timezone)
    await q.answer()

@projects_router.message(F.text, SettingsStates.set_timezone)
async def set_tz_save(m: Message, state: FSMContext):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    timezone_str = m.text.strip()
    try:
        ZoneInfo(timezone_str) # Validate timezone string
        db.update_user(m.from_user.id, {"timezone": timezone_str})
        await m.answer(TEXTS[lang]["timezone_updated"])
        await state.clear()
    except Exception:
        await m.answer(TEXTS[lang]["invalid_timezone"])

@projects_router.callback_query(F.data == "set_fmt")
async def set_fmt_start(q: CallbackQuery, state: FSMContext):
    u = db.ensure_user(q.from_user.id)
    lang = u["language"]
    await q.message.edit_text(TEXTS[lang]["set_datetime_format"])
    await state.set_state(SettingsStates.set_datetime_format)
    await q.answer()

@projects_router.message(F.text, SettingsStates.set_datetime_format)
async def set_fmt_save(m: Message, state: FSMContext):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    parts = m.text.strip().split()
    if len(parts) == 2:
        dfmt, tfmt = parts
        # Basic validation for format tokens
        # This regex checks for YYYY, MM, DD, HH, mm patterns
        date_tokens_valid = all(token in TOKEN_MAP for token in re.findall(r'(YYYY|YY|MM|DD)', dfmt))
        time_tokens_valid = all(token in TOKEN_MAP for token in re.findall(r'(HH|mm)', tfmt))

        if date_tokens_valid and time_tokens_valid:
            db.update_user(m.from_user.id, {"date_format": dfmt, "time_format": tfmt})
            await m.answer(TEXTS[lang]["datetime_format_updated"])
            await state.clear()
            return
    await m.answer(TEXTS[lang]["invalid_datetime_format"])

# –ü–û–°–¢–´: –°–û–ó–î–ê–ù–ò–ï –ß–ï–†–ï–ó FSM (–ø–æ–ª–Ω—ã–π wizard)
@posts_router.message(Command("create"))
async def create_post_start(m: Message, state: FSMContext):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    
    active_project_id = u.get("active_project_id")
    if not active_project_id:
        await m.answer(TEXTS[lang]["no_active_project"])
        return
    
    await state.update_data({"project_id": active_project_id}) # Store project_id for the post
    await m.answer(TEXTS[lang]["enter_post_text"])
    await state.set_state(CreatePost.text)

@posts_router.message(CreatePost.text)
async def post_text(m: Message, state: FSMContext):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    await state.update_data({"text": m.text})
    await m.answer(TEXTS[lang]["attach_media"])
    await state.set_state(CreatePost.media)

@posts_router.message(F.photo | F.video, CreatePost.media)
async def post_media(m: Message, state: FSMContext):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    file_id = None
    if m.photo:
        file_id = m.photo[-1].file_id
    elif m.video:
        file_id = m.video.file_id
    await state.update_data({"media": file_id})
    await m.answer(TEXTS[lang]["enter_buttons"])
    await state.set_state(CreatePost.buttons)

@posts_router.message(Command("skip"), CreatePost.media)
async def post_media_skip(m: Message, state: FSMContext):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    await state.update_data({"media": None})
    await m.answer(TEXTS[lang]["enter_buttons"])
    await state.set_state(CreatePost.buttons)

@posts_router.message(CreatePost.buttons)
async def post_buttons(m: Message, state: FSMContext):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    lines = m.text.strip().splitlines()
    buttons = []
    for line in lines:
        if "|" in line:
            txt, url = map(str.strip, line.split("|", 1))
            buttons.append({"text": txt, "url": url})
    await state.update_data({"buttons": buttons})
    await m.answer(TEXTS[lang]["publish_time"])
    await state.set_state(CreatePost.datetime)

@posts_router.message(Command("skip"), CreatePost.buttons)
async def post_buttons_skip(m: Message, state: FSMContext):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    await state.update_data({"buttons": []})
    await m.answer(TEXTS[lang]["publish_time"])
    await state.set_state(CreatePost.datetime)

@posts_router.message(CreatePost.datetime)
async def post_datetime(m: Message, state: FSMContext):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    try:
        dt = parse_dt(u, m.text.strip()) # Use parse_dt helper
    except Exception:
        await m.answer(TEXTS[lang]["invalid_date_format"])
        return
    await state.update_data({"datetime": dt.isoformat()})
    await m.answer(TEXTS[lang]["repeat_post"], reply_markup=None)
    await state.set_state(CreatePost.repeat)

@posts_router.message(Command("skip"), CreatePost.datetime)
async def post_datetime_skip(m: Message, state: FSMContext):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    now = datetime.now(timezone.utc).isoformat()
    await state.update_data({"datetime": now})
    await m.answer(TEXTS[lang]["repeat_post"])
    await state.set_state(CreatePost.repeat)

@posts_router.message(CreatePost.repeat)
async def post_repeat(m: Message, state: FSMContext):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    repeat = 0
    try:
        repeat = int(m.text.strip())
    except Exception:
        await m.answer(TEXTS[lang]["invalid_repeat_format"])
        return
    await state.update_data({"repeat": repeat})
    
    data = await state.get_data()
    active_project_id = data.get("project_id") # Get project_id from state
    
    if not active_project_id: # Should not happen if /create checks for it
        await m.answer(TEXTS[lang]["no_active_project"])
        await state.clear()
        return

    chans = db.list_channels(active_project_id)
    if not chans:
        await m.answer(TEXTS[lang]["no_channels"])
        await state.clear()
        return
    
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(c["name"], callback_data=f"pickch_{c['id']}")] for c in chans
    ])
    await m.answer(TEXTS[lang]["pick_channel"], reply_markup=kb)
    await state.set_state(CreatePost.channel)

@posts_router.callback_query(F.data.startswith("pickch_"), CreatePost.channel)
async def post_pick_channel(q: CallbackQuery, state: FSMContext):
    u = db.ensure_user(q.from_user.id)
    lang = u["language"]
    ch_id = int(q.data[7:])
    await state.update_data({"channel_id": ch_id})
    data = await state.get_data()
    
    await q.message.edit_text(TEXTS[lang]["post_saved"]) # Update message to indicate saving
    
    db.new_post({
        "text": data.get("text"),
        "media": data.get("media"),
        "buttons": data.get("buttons"),
        "publish_time": data.get("datetime"),
        "repeat_minutes": data.get("repeat"),
        "channel_id": ch_id,
        "published": False,
        "draft": False,
        "project_id": data.get("project_id") # Ensure project_id is saved with the post
    })
    await state.clear()
    await q.message.answer(TEXTS[lang]["post_saved"]) # Send final confirmation
    await q.answer()

# –õ–ò–°–¢–ò–ù–ì, –£–î–ê–õ–ï–ù–ò–ï, –†–ï–î–ê–ö–¢–ò–†–û–í–ê–ù–ò–ï –ü–û–°–¢–û–í
@posts_router.message(Command("list"))
async def list_posts(m: Message):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    
    active_project_id = u.get("active_project_id")
    if not active_project_id:
        await m.answer(TEXTS[lang]["no_active_project"])
        return

    posts = db.client.table("posts").select("*").eq("project_id", active_project_id).order("publish_time", desc=False).execute().data
    
    if not posts:
        await m.answer(TEXTS[lang]["no_posts_yet"])
        return
    
    for p in posts:
        txt = (p["text"] or "")[:60] + ("‚Ä¶" if p["text"] and len(p["text"]) > 60 else "")
        dt = p["publish_time"][:16].replace("T", " ")
        status = "‚úÖ" if p.get("published") else "üïì"
        
        await m.answer(
            f"{status} <b>{dt}</b>\n{txt}",
            parse_mode="HTML",
            reply_markup=InlineKeyboardMarkup(
                inline_keyboard=[
                    [
                        InlineKeyboardButton("üëÅÔ∏è", callback_data=f"prev_{p['id']}"),
                        InlineKeyboardButton("‚úèÔ∏è", callback_data=f"edit_{p['id']}"),
                        InlineKeyboardButton("üóëÔ∏è", callback_data=f"del_{p['id']}")
                    ]
                ]
            )
        )

@posts_router.callback_query(F.data.startswith("prev_"))
async def preview_post(q: CallbackQuery):
    u = db.ensure_user(q.from_user.id)
    lang = u["language"]
    post_id = int(q.data[5:])
    p = db.get_post(post_id)
    if not p:
        await q.answer(TEXTS[lang]["post_not_found"], show_alert=True)
        return
    
    txt = p["text"]
    btns = None
    try:
        if p.get("buttons"):
            btns_list = json.loads(p["buttons"])
            if btns_list:
                btns = InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(b["text"], url=b["url"])] for b in btns_list
                ])
    except Exception:
        pass # Malformed JSON or other button issues
    
    if p.get("media"):
        try:
            await bot.send_photo(q.from_user.id, p["media"], caption=txt, reply_markup=btns)
        except Exception:
            await q.message.answer(txt, reply_markup=btns) # Fallback if photo fails
    else:
        await q.message.answer(txt, reply_markup=btns)
    await q.answer()

@posts_router.callback_query(F.data.startswith("del_"))
async def delete_post_cb(q: CallbackQuery):
    u = db.ensure_user(q.from_user.id)
    lang = u["language"]
    post_id = int(q.data[4:])
    db.delete_post(post_id)
    await q.message.edit_text(TEXTS[lang]["post_deleted"])
    await q.answer()

@posts_router.callback_query(F.data.startswith("edit_"))
async def edit_post_cb(q: CallbackQuery, state: FSMContext):
    u = db.ensure_user(q.from_user.id)
    lang = u["language"]
    post_id = int(q.data[5:])
    p = db.get_post(post_id)
    if not p:
        await q.answer(TEXTS[lang]["post_not_found"], show_alert=True)
        return
    
    await state.update_data({"edit_id": post_id})
    await q.message.answer(TEXTS[lang]["enter_new_post_text"])
    await state.set_state("edit_post_text") # This state needs to be defined in FSMStates if it's not
    await q.answer()

@posts_router.message(F.text, lambda m, state: state.get_state() == "edit_post_text") # This state needs to be defined in FSMStates
async def edit_post_text(m: Message, state: FSMContext):
    u = db.ensure_user(m.from_user.id)
    lang = u["language"]
    data = await state.get_data()
    post_id = data.get("edit_id")
    db.update_post(post_id, {"text": m.text})
    await m.answer(TEXTS[lang]["text_updated"])
    await state.clear()

# –ê–í–¢–û–ü–£–ë–õ–ò–ö–ê–¶–ò–Ø ‚Äî –ü–ï–†–ò–û–î–ò–ß–ï–°–ö–ò–ô LOOP
async def autoposter():
    while True:
        try:
            now = datetime.now(timezone.utc).isoformat(timespec="minutes")
            pending = db.pending_posts(now)
            
            for p in pending:
                ch = db.client.table("channels").select("*").eq("id", p["channel_id"]).execute().data
                if not ch:
                    logging.warning(f"Channel with ID {p['channel_id']} not found for post {p['id']}. Skipping.")
                    continue
                
                ch_id = ch[0]["chat_id"]
                btns = None
                try:
                    if p.get("buttons"):
                        btns_list = json.loads(p["buttons"])
                        if btns_list:
                            btns = InlineKeyboardMarkup(inline_keyboard=[
                                [InlineKeyboardButton(b["text"], url=b["url"])] for b in btns_list
                            ])
                except json.JSONDecodeError as e:
                    logging.error(f"Error parsing buttons for post {p['id']}: {e}. Buttons will not be sent.")
                    btns = None
                except Exception as e:
                    logging.error(f"Unexpected error with buttons for post {p['id']}: {e}. Buttons will not be sent.")
                    btns = None
                
                try:
                    if p.get("media"):
                        await bot.send_photo(ch_id, p["media"], caption=p["text"], reply_markup=btns)
                    else:
                        await bot.send_message(ch_id, p["text"], reply_markup=btns)
                    
                    db.mark_published(p["id"]) # Mark as published after successful sending
                    logging.info(f"Post {p['id']} successfully published to channel {ch_id}.")
                    
                    # –ü–æ–≤—Ç–æ—Ä? –ì–µ–Ω–µ—Ä–∏–º –∫–æ–ø–∏—é —Å –Ω–æ–≤—ã–º –≤—Ä–µ–º–µ–Ω–µ–º, –µ—Å–ª–∏ repeat_minutes > 0
                    if p.get("repeat_minutes") and int(p["repeat_minutes"]) > 0:
                        dt = datetime.fromisoformat(p["publish_time"])
                        new_dt = dt + timedelta(minutes=int(p["repeat_minutes"]))
                        
                        # Ensure project_id is passed for new post
                        project_id = ch[0]["project_id"] # Get project_id from channel
                        
                        db.new_post({
                            "text": p["text"],
                            "media": p.get("media"),
                            "buttons": p.get("buttons"),
                            "publish_time": new_dt.isoformat(),
                            "repeat_minutes": p["repeat_minutes"],
                            "channel_id": p["channel_id"],
                            "published": False,
                            "draft": False,
                            "project_id": project_id # Add project_id to the new post
                        })
                        logging.info(f"New repeat post created for post {p['id']} with publish time {new_dt.isoformat()}.")
                except Exception as ex:
                    logging.error(f"Error publishing post {p['id']} to channel {ch_id}: {ex}", exc_info=True)
                    # Optionally, mark post as failed or retry later
            
            await asyncio.sleep(30) # Check every 30 seconds
        except Exception as e:
            logging.critical(f"Critical error in autoposter loop: {e}", exc_info=True)
            await asyncio.sleep(60) # Wait longer if a critical error occurs to prevent rapid looping

# –û–ë–©–ò–ô –°–¢–ê–†–¢, –û–ë–†–ê–ë–û–¢–ö–ê –û–®–ò–ë–û–ö, –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï ROUTERS
dp.include_router(base_router)
dp.include_router(channels_router)
dp.include_router(projects_router)
dp.include_router(posts_router)

@dp.errors()
async def error_handler(update, error):
    try:
        msg = getattr(update, "message", None) or getattr(update, "callback_query", None)
        user_id = msg.from_user.id if msg else None
        
        logging.error(f"Update: {update} caused error: {error}", exc_info=True)
        
        if user_id:
            u = db.get_user(user_id)
            lang = u["language"] if u else "ru"
            error_message = f"{TEXTS[lang]['error']}: {error}"
            if "A request to the Telegram API was unsuccessful" in str(error):
                error_message = f"{TEXTS[lang]['error']}: –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–∏ —Å Telegram API. –í–æ–∑–º–æ–∂–Ω–æ, –±–æ—Ç –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º –∫–∞–Ω–∞–ª–∞ –∏–ª–∏ –∫–∞–Ω–∞–ª –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω."
            elif "Bad Request: chat not found" in str(error):
                error_message = f"{TEXTS[lang]['error']}: –ö–∞–Ω–∞–ª –Ω–µ –Ω–∞–π–¥–µ–Ω. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ ID –∫–∞–Ω–∞–ª–∞ –≤–µ—Ä–µ–Ω –∏ –±–æ—Ç –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∫–∞–Ω–∞–ª."
            elif "Forbidden: bot was blocked by the user" in str(error):
                error_message = f"{TEXTS[lang]['error']}: –ë–æ—Ç –±—ã–ª –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Ä–∞–∑–±–ª–æ–∫–∏—Ä—É–π—Ç–µ –±–æ—Ç–∞."
            
            if msg:
                await msg.answer(error_message)
    except Exception as e:
        logging.critical(f"Error in error_handler itself: {e}", exc_info=True)
        if msg:
            await msg.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –≤ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–µ –æ—à–∏–±–æ–∫.")

async def main():
    logging.info("Starting bot...")
    # –ú–æ–∂–Ω–æ —Å—Ä–∞–∑—É –≥–æ–Ω—è—Ç—å –¥–≤–∞ –∫–æ—Ä—É—Ç–∏–Ω—ã ‚Äî polling –∏ –∞–≤—Ç–æ–ø–æ—Å—Ç–µ—Ä
    await asyncio.gather(
        dp.start_polling(bot, skip_updates=True),
        autoposter()
    )

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        logging.info("Bot stopped.")
